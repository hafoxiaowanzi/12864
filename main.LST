C51 COMPILER V9.00   MAIN                                                                  01/20/2015 08:52:26 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*********---------------------------------------------------------------------------
   2                          电子智能时钟程序
   3                          单 片 机：STC89C52RC
   4                          晶    振：12MHz
   5                          时钟芯片：DS1302
   6                          液 晶 屏：LCM-12864-ST7920
   7                          时    间：2010年10月10日修改完成
   8                          LCM12864使用并口连接方式,PSB、RST接高电平
   9          ------------------------------------------------------------------------------*/
  10          
  11          /*-------------------------------头文件---------------------------------------*/
  12          #include <reg52.h>
  13          #include <intrins.h>
  14          #include "LCD12864.h"
  15          #include "DS1307.h"
  16          #include "nongli.h"
  17          #include "displaytime.h"
  18          //#include "jieqi.h"
  19          #define uint  unsigned int
  20          #define uchar unsigned char
  21          
  22          /*---------------------函数声明------------------------------*/
  23          sbit K1  = P2^0; //K1-设置
  24          sbit K2  = P2^1; //K2-确认、返回
  25          sbit K3  = P2^2; //K3-加
  26          sbit K4  = P2^3; //K4-减
  27          
  28          sbit K5  = P2^4; //液晶背光控制按键，按一下亮，再按一下灭
  29          sbit LCD = P3^6; //液晶背光控制输出，低电平有效，PNP三极管控制。
  30          sbit beep = P3^7;
  31          unsigned char  yy,mo,dd,xq,hh,mm,ss, naoh,naom,month_moon,day_moon,week,tiangan,dizhi,moontemp1,moontemp2;
             -//定义时间映射全局变量（专用寄存器）
  32          void Disp_Img(unsigned char code *img);
  33          void DelayM(uint);              
  34          void ds_w(void);
  35          void Conver_week(bit c,uchar year,uchar month,uchar day);
  36          /*-----------------------------定义全局变量------------------------------*/
  37          bit q=0, w=0,BEEP_bit = 0,flag = 0;    //调时标志位
  38          signed char address,item,max,mini;
  39          /******************************************************************************************/
  40          /*-----------------------------延时函数 1MS/次-------------------------------*/
  41          void DelayM(uint a)             
  42          {
  43   1              uchar i;
  44   1              while( --a != 0) { for(i = 0; i < 125; i++); }                                     
  45   1      }
  46          /*-----------------------------日期、时间设置函数-----------------------------*/
  47          
  48          void tiaozheng(void)
  49          {
  50   1              yy = read_clock(0x06);//调用1307时钟数据中的年数据，从地址0x06中
  51   1              mo = read_clock(0x05);//调用1307时钟数据中的月数据，从地址0x05中
  52   1              dd = read_clock(0x04);//从1307芯片中读取日数据，从地址0x04中
  53   1              week = read_clock(0x03);//从1307芯片中读取星期数据，从地址0x8b中
  54   1              lcm_w_test(0,0x80);
C51 COMPILER V9.00   MAIN                                                                  01/20/2015 08:52:26 PAGE 2   

  55   1      
  56   1              lcm_w_word("20");//显示内容字符20
  57   1              write_data(yy/16+0x30);//函数参数1，代表本行写数据，YY/16+0X30得出年十位数字的显示码地址，送显示        
  58   1              write_data(yy%16+0x30);//函数
  59   1              lcm_w_word("年");
  60   1      
  61   1              write_data(mo/16+0x30);
  62   1              write_data(mo%16+0x30);//与16取余数，得到月份的个位数，加0x30得到该数字的液晶内定显示码送显示
  63   1              lcm_w_word("月");//调用字符显示函数，显示文字 月
  64   1      
  65   1              write_data(dd/16+0x30);
  66   1              write_data(dd%16+0x30);//第一个1参数，表示本行写数据，日数据与16取余得个位数，加0x30得到显示码
  67   1              lcm_w_word("日");//显示字符 日
  68   1      
  69   1              if(read_clock(0x02) != hh){//如果程序中的小时与1302芯片中的不同，
  70   2                      hh = read_clock(0x02);//刷新程序中的小时数据
  71   2              }
  72   1              lcm_w_test(0,0x91);//第一个参数0，表示本行写入LCM的是指令，指定显示位置91H（第三行左端）
  73   1              write_data(hh/16+0x30);//显示十位
  74   1              write_data(hh%16+0x30);//显示个位
  75   1              lcm_w_word("时");
  76   1      
  77   1              if(read_clock(0x01) != mm){//如果1307芯片中的分钟数据与程序中的分钟变量不相等           
  78   2                      mm = read_clock(0x01);//刷新程序中的分钟数据
  79   2              }
  80   1              write_data(mm/16+0x30);//向液晶写数据，显示分钟的十位数
  81   1              write_data(mm%16+0x30);//向液晶写数据，显示分钟的个位数
  82   1              lcm_w_word("分");
  83   1      
  84   1              if(read_clock(0x00) != ss){//如果1307芯片中的分钟数据与程序中的秒钟变量不相等           
  85   2                      ss = read_clock(0x00);//刷新程序中的秒钟数据
  86   2              }
  87   1              write_data(ss/16+0x30);//向液晶写数据，显示分钟的十位数
  88   1              write_data(ss%16+0x30);//向液晶写数据，显示分钟的个位数
  89   1              lcm_w_word("秒");
  90   1      
  91   1              if(read_clock(0x08) != ss){//如果1307芯片中的分钟数据与程序中的秒钟变量不相等           
  92   2                 ss = read_clock(0x08);//刷新程序中的秒钟数据
  93   2              }
  94   1      /*************************************************************************/
  95   1              lcm_w_test(0,0x88);
  96   1              lcm_w_word("闹钟：");
  97   1              if(read_clock(0x08) != naoh){//如果1307芯片中的分钟数据与程序中的秒钟变量不相等         
  98   2                naoh = read_clock(0x08);//刷新程序中的秒钟数据
  99   2              }
 100   1              write_data(naoh/16+0x30);//向液晶写数据，显示分钟的十位数
 101   1              write_data(naoh%16+0x30);//向液晶写数据，显示分钟的个位数
 102   1              lcm_w_word("时");
 103   1      
 104   1              if(read_clock(0x09) != naom){//如果1307芯片中的分钟数据与程序中的秒钟变量不相等         
 105   2                naom = read_clock(0x09);//刷新程序中的秒钟数据
 106   2              }
 107   1              write_data(naom/16+0x30);//向液晶写数据，显示分钟的十位数
 108   1              write_data(naom%16+0x30);//向液晶写数据，显示分钟的个位数
 109   1              lcm_w_word("分");
 110   1      }
 111          
 112          /*********************************************************************************************************
             -*/
 113          //调整时间子函数，设置键、数据范围、上调加一，下调减一功能。
 114          void Set_time(unsigned char sel){ //根据选择调整的相应项目加1并写入DS1307，函数参数是按动设置键的次数
 115   1              uchar a = 0;
C51 COMPILER V9.00   MAIN                                                                  01/20/2015 08:52:26 PAGE 3   

 116   1              write_com(0x30); write_com(0x06);
 117   1      
 118   1              lcm_w_test(0,0x98);//第一参数0表示本行写入指令，指定下面行的 调整 显示起始位置为98H
 119   1              lcm_w_word("★调整");//调用字符显示函数，显示 调整字样
 120   1              if(sel == 6){lcm_w_word("闹分");address=0x09; max=59;mini=0;
 121   2              tiaozheng();
 122   2              ds_w();
 123   2              tiaozheng();
 124   2              }
 125   1              if(sel == 5){lcm_w_word("闹时");address=0x08; max=23;mini=0;
 126   2              tiaozheng();
 127   2              ds_w();
 128   2              tiaozheng();
 129   2              }
 130   1          if(sel==4)  {lcm_w_word("分钟");address=0x01; max=59;mini=0;
 131   2              tiaozheng();
 132   2              ds_w();
 133   2              tiaozheng();
 134   2        
 135   2              }               
 136   1                      //分钟6，按动6次显示 调整分钟
 137   1              //并指定分钟数据写入1307芯片的地址是0x01，分钟数据的最大值是59，最小值是0
 138   1              if(sel==3)  {lcm_w_word("小时");address=0x02; max=23;mini=0;
 139   2        
 140   2              tiaozheng();
 141   2              ds_w();
 142   2                  tiaozheng();
 143   2        
 144   2              }       //小时5，按动5次显示 调整小时
 145   1                      //规定小时数据写入1307芯片的位置是0x02，小时数据最大值23，最小值是0
 146   1              if(sel==2)  {lcm_w_word("日期");
 147   2                      address=0x04; 
 148   2                      mo = read_clock(0x05);//读月数据
 149   2                      moontemp1=mo/16;
 150   2                      moontemp2=mo%16;
 151   2                      mo=moontemp1*10+moontemp2;//转换成10进制月份数据
 152   2      
 153   2              yy = read_clock(0x06);//读年数据
 154   2              moontemp1=yy/16;
 155   2                      moontemp2=yy%16;
 156   2                      yy=moontemp1*10+moontemp2;//转换成10进制年份数据 
 157   2      
 158   2              if(mo==2&&yy%4!=0){max=28;mini=1;}//平年2月28天
 159   2                      if(mo==2&&yy%4==0){max=29;mini=1;}//闰年2月29天
 160   2                      if(mo==1||mo==3||mo==5||mo==7||mo==8||mo==10||mo==12){max=31;mini=1;}//31天的月份
 161   2                      if(mo==4||mo==6||mo==9||mo==11){max=30;mini=1;}//30天的月份
 162   2                      tiaozheng();
 163   2                      ds_w();
 164   2                      tiaozheng(); //调用日期、时间调整函数
 165   2       
 166   2        }     //日3，按动3次显示 调整日期
 167   1              //规定日期数据写入1302的位置地址是0x86，日期最大值31，最小值是1
 168   1        if(sel==1)  {lcm_w_word("月份");address=0x05; max=12;mini=1;
 169   2           tiaozheng();
 170   2           ds_w();
 171   2           tiaozheng();
 172   2        
 173   2         }    //月2，按动2次显示 调整月份
 174   1              //规定月份写入1302的位置地址是0x88，月份最大值12，最小值1
 175   1        if(sel==0)  {lcm_w_word("年份");address=0x06; max=99; mini=0;
 176   2           tiaozheng();
 177   2           ds_w();            //被调数据加一或减一函数
C51 COMPILER V9.00   MAIN                                                                  01/20/2015 08:52:26 PAGE 4   

 178   2           tiaozheng();       //调用日期、时间调整函数
 179   2      
 180   2         }    //年1，按动1次显示 调整年份，
 181   1                      //规定年份写入1302的地址是0x8c,年份的最大值99，最小值0
 182   1      
 183   1      }
 184          
 185          /*****************************************************************************/
 186          //被调数据加一或减一，并检查数据范围，写入1302指定地址保存
 187          void ds_w(void){
 188   1      
 189   1              item=((read_clock(address))/16)*10 + (read_clock(address))%16;
 190   1              if(K3 == 0){//如果按动上调键
 191   2                      item++;//数加 1  
 192   2              }
 193   1              if(K4 == 0){//如果按动下调键
 194   2                      item--;//数减 1 
 195   2              }
 196   1              if(item>max) item=mini;//查看数值是否在有效范围之内   
 197   1              if(item<mini) item=max;//如果数值小于最小值，则自动等于最大值           
 198   1      
 199   1              write_clock(address,(item/10)*16+item%10);//转换成16进制写入1307
 200   1      
 201   1      }
 202          /****************************************************************************/
 203          
 204          /*********************************************************************/
 205          void Timer0_Init(void) //定时器0初始（主函数中被调用一次）
 206          {
 207   1              TMOD=0x01;//定时器方式设置（定时器工作方式1-16位定时）
 208   1              TH0=(65535-50000)/256;//50MS
 209   1              TL0=(65535-50000)%256;
 210   1              EA=1;//开总中断
 211   1              ET0=1;//开定时器0中断允许 
 212   1              TR0=1;//启动定时器0
 213   1      }
 214          /*********************************************************************************/
 215          /*主函数---------------------------------------------------------------------*/
 216          void main()
 217          {
 218   1                               
 219   1              uchar e = 0,a = 0;
 220   1              K1=1;K2=1;K3=1;K4=1;K5=1;LCD=1;beep=1;
 221   1          init();     
 222   1              lcm_init();                     //液晶初始化
 223   1          Init_1307();                //时钟芯片初始化
 224   1              welcome();              //调用欢迎信息
 225   1              DelayM(200);            //延时
 226   1              lcm_clr();
 227   1              Clean_12864_GDRAM();     //清屏
 228   1              Timer0_Init(); 
 229   1              while(1)
 230   1              {
 231   2                      if (w == 0)              //正常走时
 232   2                      { 
 233   3                              displaydate();   //显示日期
 234   3                              nongli();                //显示农历
 235   3                              displaytime();   //显示时间
 236   3                              displaylamptemp(); //显示温度            
 237   3                              displayxq();     //显示星期
 238   3                              
 239   3                      }       
C51 COMPILER V9.00   MAIN                                                                  01/20/2015 08:52:26 PAGE 5   

 240   2      /*----------------------------设置时间--------------------------------------*/          
 241   2                      if (K1 == 0)         
 242   2                      {
 243   3                              DelayM(20);                    //按键消抖
 244   3                              if(K1 == 0 && w == 1)      //当是调时状态 本键用于调整下一项
 245   3                              {
 246   4                                      e++;
 247   4                                      if (e >= 7 ) {e = 0;}
 248   4                              while(! K1 );            //等待键松开 
 249   4                                      Set_time(e);           //调整                           
 250   4                              }                       
 251   3                              if(K1 == 0 && w == 0)      //当是正常状态时就进入调时状态
 252   3                              {
 253   4                                      lcm_clr();            
 254   4                                      Clean_12864_GDRAM();   //清屏
 255   4                                      w=1;                   //进入调时
 256   4                                      Set_time(e);
 257   4                              }
 258   3                              while(K1 == 0);            //等待键松开 
 259   3                      }
 260   2      /*--------------------------------------------------------------------------*/          
 261   2                      if (K2 == 0)                   // 当在调时状态时就退出调时
 262   2                      {
 263   3                              BEEP_bit =1; 
 264   3                              DelayM(20);
 265   3                              if(K2 == 0 && w == 1)
 266   3                              {                               
 267   4                                      w = 0;                 //退出调时
 268   4                                      e = 0;                     //"下一项"计数器清0                                                          
 269   4                              }
 270   3                              if(K2 == 0 && w == 0) 
 271   3                              {                               
 272   4                                      lcm_clr(); Clean_12864_GDRAM();
 273   4                                      write_com(0x30); write_com(0x06);
 274   4                                      welcome();                              
 275   4                                      while(K2 == 0);  
 276   4                              }
 277   3                              lcm_clr(); Clean_12864_GDRAM();
 278   3                              displaydate();
 279   3                              displayxq(); 
 280   3                              displaynl();
 281   3                              displaytime();
 282   3                              displaylamptemp();
 283   3                        
 284   3                              while(K2 == 0);  
 285   3                      }
 286   2      /*加调整--------------------------------------------------------------------*/          
 287   2                      if (K3 == 0 && w == 1)
 288   2                      { 
 289   3                              DelayM(20);
 290   3                              if(K3 == 0 && w == 1) { Set_time(e); }
 291   3                              while(! K3 );
 292   3                      }
 293   2      /*减调整--------------------------------------------------------------------*/          
 294   2                      if (K4 == 0 && w == 1) 
 295   2                      {               
 296   3                              DelayM(20);
 297   3                              if(K4 == 0 && w == 1) { Set_time(e); }
 298   3                              while(! K4 );
 299   3                      }
 300   2      /*液晶背光控制，按一下亮，再按一下灭----------------------------------------*/
 301   2                      if(K5 == 0)        
C51 COMPILER V9.00   MAIN                                                                  01/20/2015 08:52:26 PAGE 6   

 302   2                      {
 303   3                      
 304   3                              DelayM(20); q = ~q;      //标志位取反
 305   3                              if(q){LCD = LCD| 1;}   
 306   3                                      else {LCD = LCD & 0;}   
 307   3                              while(K5 == 0);           
 308   3                      }
 309   2      /**********************************************************************************/
 310   2                                 /*----------验证闹钟---------------*/
 311   2                                         
 312   2                   if(read_clock(0x08) == read_clock(0x02)&&read_clock(0x09) == read_clock(0x01))
 313   2                       {
 314   3                                   char i;  
 315   3                                      if(BEEP_bit == 1 && w == 0)
 316   3                                  {
 317   4                                              flag = 1;
 318   4      
 319   4      
 320   4                                      
 321   4                                      for(i=0;i<4;i++)
 322   4                                         {
 323   5                                                  if(i>4)i = 0;
 324   5                                                  beep = 0;  //打开峰鸣器
 325   5                                                      DelayM(80);//延时
 326   5                                                      beep = 1;  //关闭峰鸣器
 327   5                                                      DelayM(125);
 328   5                                         }                    
 329   4                                      }
 330   3                                      else if(flag == 0)
 331   3                                      {
 332   4                                              BEEP_bit =1; 
 333   4                                              
 334   4                                      }
 335   3                       }
 336   2                       else
 337   2                       {
 338   3                                flag = 0;
 339   3                       }
 340   2      
 341   2          }
 342   1      }
 343          /**********************************************************************************************/        
 344          void tiemr0()interrupt 1//定时器0初始（主函数中被调用一次）
 345          {
 346   1              
 347   1              TH0=(65535-50000)/256;//50MS
 348   1              TL0=(65535-50000)%256;
 349   1              if(K4 == 0 && flag == 1)
 350   1              {
 351   2                      DelayM(20);
 352   2                      BEEP_bit = 0;
 353   2                      beep = 1;
 354   2                      while(!K4);
 355   2              }
 356   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5103    ----
   CONSTANT SIZE    =   1729    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.00   MAIN                                                                  01/20/2015 08:52:26 PAGE 7   

   DATA SIZE        =     37      43
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6       5
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
